<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>00 Schn31der</title>
        <script src="https://unpkg.com/wavesurfer.js@7"></script>
        <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
        <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/zoom.min.js"></script>
        <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/timeline.min.js"></script>
        <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/minimap.min.js"></script>
        <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/hover.min.js"></script>
        <script src="simplepeer.min.js"></script>
        <script src="config.js"></script>
        <script src="get_wav_bytes.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
        <!-- <script src="libflac.js"></script> -->

        <style type="text/css">
            body {
                background-color: black;
                color: white;
            }

            #waveform {
                font-size: 10px;
                cursor: pointer;
            }

            #waveform ::part(region-content) {
                width: 99%;
                text-align: justify;
                margin-top: 20px !important;
                font-size: 14px;
                color: white;
            }

            #waveform ::part(region-content):after {
                content: "";
                display: inline-block;
                width: 100%;
            }

            #time,
            #duration {
                position: absolute;
                z-index: 11;
                top: -326px;
                margin-top: -1px;
                background: rgba(0, 0, 0, 0.75);
                padding: 2px;
                color: #ddd;
                font-size: 20px;
            }

            #time {
                left: 0;
            }

            #duration {
                right: 0;
            }

            #overlay-container {
                position: relative;
            }

            #working {
                position: absolute;
                z-index: 10;
                top: -350px;
                width: 100%;
                text-align: center;
            }

            .waviy {
                position: relative;
                -webkit-box-reflect: below -20px linear-gradient(transparent, rgba(0,0,0,.2));
                font-size: 60px;
            }

            .waviy span {
                position: relative;
                display: inline-block;
                color: #fff;
                animation: waviy 1s infinite;
                animation-delay: calc(.1s * var(--i));
            }

            @keyframes waviy {
                0%,40%,100% {
                    transform: translateY(0)
                }
                20% {
                    transform: translateY(-20px)
                }
            }

            .toolbar {
                margin: 20px 0;
                display: flex;
                justify-content: flex-start;
            }

            .tools {
                flex: none;
                padding: 0 10px;
                border-right: 2px solid grey;
            }

            .tools:first-child {
                padding-left: 0;
            }

            .tool-wrapper {
                display: inline-block;
                position: relative;
            }

            .tool {
                min-width: 70px;
            }

            .tool.working {
                color: yellow;
            }

            button + .shortcut {
                display: none;
                color: yellow;
                position: absolute;
                top: -20px; /* Adjust this value to move the element up */
                left: 50%;
                transform: translateX(-50%);
            }

            button:disabled + .shortcut {
                display: none !important;
            }

            .toolbar.show-shortcuts .shortcut {
                display: inline-block;
                white-space: nowrap;
            }


            #hints {
                color: yellow;
            }
        </style>
    </head>
    <body>
        <div class="toolbar">
            <div id="open-save" class="tools">
                <input id="open-file" class="tool" type="file" accept=".wav,.mp3,.webm,.ogg,.flac">
                <button id="save-wav" class="tool">Save as WAV</button>
            </div>

            <div id="autosave-tools" class="tools">
                <button id="toggle-autosave" class="tool">Enable Autosave</button>
                <span id="autosave-state" class="tool"></span>
            </div>

            <div id="transcription" class="tools">
                <span class="tool">Transcription:</span>
                <select id="transcription-lang" class="tool">
                    <option value="">â€“</option>
                    <option value="en">English</option>
                    <option value="de">German</option>
                </select>
                <span id="transcribe-health" class="tool"></span>
            </div>

            <div id="zoom" class="tools">
                <span id="min-px-per-sec" class="tool"></span>
            </div>

            <div id="extras" class="tools">
                <button id="connect-to-text-page" class="tool">Connect to text page</button>
                <span id="connected-to-text-page" class="tool"></span>
            </div>
        </div>

        <div id="waveform"></div>

        <div id="overlay-container">
            <div id="time"></div>
            <div id="duration"></div>
            <div id="working" class="waviy">
            </div>
        </div>

        <div class="toolbar">
            <div id="playpause" class="tools">
                <div class="tool-wrapper">
                    <button id="pause">Play / Pause</button>
                    <span class="shortcut" for="pause">SPACE</span>
                </div>
            </div>
            <div id="copypaste" class="tools">
                <div class="tool-wrapper">
                    <button id="copy" class="tool for-selection" disabled>Copy</button>
                    <span class="shortcut" for="cut">CTRL-C</span>
                </div>
                <div class="tool-wrapper">
                    <button id="paste" class="tool for-copy" disabled>Paste</button>
                    <span class="shortcut" for="cut">CTRL-P</span>
                </div>
                <div class="tool-wrapper">
                    <button id="cut" class="tool for-selection" disabled>Cut</button>
                    <span class="shortcut" for="cut">CTRL-X</span>
                </div>
            </div>
            <div id="effects" class="tools">
                <div class="tool-wrapper">
                    <button id="strangle" class="tool for-selection" disabled>Strangle</button>
                    <span class="shortcut" for="strangle">CTRL-M</span>
                </div>
                <div class="tool-wrapper">
                    <button id="insert-silence" class="tool">Insert silence</button>
                    <span class="shortcut" for="insert-silence">CTRL-I</span>
                </div>
            </div>
            <div class="tools">
                <div class="tool-wrapper">
                    <button id="undo" class="tool" disabled>Undo</button>
                    <span class="shortcut" for="undo">CTRL-Z</span>
                </div>
            </div>
        </div>

        <div id="hints">
            Show shortcuts with &lt;CTRL&gt; 
        </div>

        <script>
            const SAMPLE_RATE = 44_100
            const MIN_ZOOM = 10
            const MAX_ZOOM = 500

            let currentRegion
            let copiedData

            async function getAudioForURL(url) {
                const response = await fetch(url)
                const buffer = await response.arrayBuffer()

                const ctx = new AudioContext({
                    sampleRate: SAMPLE_RATE,
                    numChannels: 1
                })
                const audioBuffer = await ctx.decodeAudioData(buffer)
                return audioBuffer
            }

            async function loadDecodedBuffer(waveSurfer, audioBuffer) {
                const wavBytes = getWavBytes(audioBuffer.getChannelData(0).buffer, {
                    isFloat: true,       // floating point or 16-bit integer
                    numChannels: 1,
                    sampleRate: 44100,
                })
                const wavBlob = new Blob([wavBytes], { type: 'audio/wav' })
                const peaks = [ audioBuffer.getChannelData(0) ]
                const duration = audioBuffer.duration
                await waveSurfer.loadBlob(wavBlob, peaks, duration)

                return wavBlob
            }

            async function copy(audioBuffer, startSeconds, endSeconds) {
                const data = audioBuffer.getChannelData(0)
                const start = Math.floor(startSeconds * audioBuffer.sampleRate)
                const end = Math.floor(endSeconds * audioBuffer.sampleRate)
                const dataToCopy = data.subarray(start, end)
                const length = end - start

                const newData = new Float32Array(length)
                newData.set(dataToCopy)

                return newData
            }

            async function paste(audioBuffer, copiedData, currentTime) {
                const currentData = audioBuffer.getChannelData(0)
                const seconds = copiedData.length / audioBuffer.sampleRate
                const start = Math.floor(currentTime * audioBuffer.sampleRate)
                const end = Math.floor((currentTime + seconds) * audioBuffer.sampleRate)

                const before = currentData.subarray(0, start)
                const after = currentData.subarray(start)

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
                const newAudioBuffer = audioCtx.createBuffer(1, before.length + copiedData.length + after.length, audioBuffer.sampleRate)
                const newData = newAudioBuffer.getChannelData(0)

                newData.set(before)
                newData.set(copiedData, before.length)
                newData.set(after, before.length + copiedData.length)

                return newAudioBuffer
            }

            async function cut(audioBuffer, startSeconds, endSeconds) {
                const data = audioBuffer.getChannelData(0)
                const start = Math.floor(startSeconds * audioBuffer.sampleRate)
                const end = Math.floor(endSeconds * audioBuffer.sampleRate)
                const before = data.subarray(0, start)
                const after = data.subarray(end)
                const dataToCopy = data.subarray(start, end)

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
                const newAudioBuffer = audioCtx.createBuffer(1, before.length + after.length, audioBuffer.sampleRate)
                const newData = newAudioBuffer.getChannelData(0)
                newData.set(before)
                newData.set(after, before.length)

                copiedData = new Float32Array(dataToCopy.length)
                copiedData.set(dataToCopy)

                return [newAudioBuffer, copiedData]
            }

            function fadeAudio(audioData, envelope) {
                function lerp(a, b, t) {
                    return a + (b - a) * t;
                }

                function fadeInOut(data, start, end, gainStart, gainEnd) {
                    // console.debug("fadeInOut", start, end, gainStart, gainEnd)

                    for (let i = start; i < end; i++) {
                        const gain = lerp(gainStart, gainEnd, (i - start) / (end - start))
                        if (i == start) console.debug("gain", i, gain, data[i], data[i] * gain / 100)
                        data[i] *= gain / 100;
                    }
                }

                for (let i = 0; i < envelope.length - 1; i++) {
                    const fadeStart = Math.round(audioData.length * envelope[i][0] / 100)
                    const fadeEnd = Math.round(audioData.length * envelope[i + 1][0] / 100)
                    const gainStart = envelope[i][1]
                    const gainEnd = envelope[i + 1][1]

                    fadeInOut(audioData, fadeStart, fadeEnd, gainStart, gainEnd)
                }
            }

            async function strangle(audioBuffer, startSeconds, endSeconds) {
                const data = audioBuffer.getChannelData(0)
                const start = Math.floor(startSeconds * audioBuffer.sampleRate)
                const end = Math.floor(endSeconds * audioBuffer.sampleRate)

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
                const newAudioBuffer = audioCtx.createBuffer(1, data.length, audioBuffer.sampleRate)
                const newData = newAudioBuffer.getChannelData(0)
                newData.set(data)

                const dataToChange = newData.subarray(start, end)
                const envelope = [[0, 100], [10, 50], [15, 35], [26, 20], [36, 10], [50, 3], [64, 10], [74, 20], [85, 35], [90, 50], [100, 100]]
                fadeAudio(dataToChange, envelope)

                return newAudioBuffer
            }

            async function insertSilence(audioBuffer, startInSeconds, lengthInSeconds) {
                const currentData = audioBuffer.getChannelData(0)
                const start = Math.floor(startInSeconds * audioBuffer.sampleRate)
                const end = Math.floor((startInSeconds + lengthInSeconds) * audioBuffer.sampleRate)
                const length = (lengthInSeconds * audioBuffer.sampleRate)

                const before = currentData.subarray(0, start)
                const after = currentData.subarray(start)

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
                const newAudioBuffer = audioCtx.createBuffer(1, before.length + length + after.length, audioBuffer.sampleRate)
                const newData = newAudioBuffer.getChannelData(0)

                newData.set(before)
                newData.set(after, before.length + length)

                return newAudioBuffer
            }

            function stringHash(string) {
                let hash = 0, i, chr

                if (string.length === 0) return hash

                for (i = 0; i < string.length; i++) {
                    const chr = string.charCodeAt(i)
                    hash = ((hash << 5) - hash) + chr
                    hash |= 0 // Convert to 32bit integer
                }

                return hash
            }

            function hashToString(hash) {
                return Array.from(new Uint8Array(hash)).map(byte =>
                    ('00' + (byte & 0xFF).toString(16)).slice(-2)
                ).join('');
            }

            async function checkCache(audioData) {
                const crypto = window.crypto || window.msCrypto

                const hash = hashToString(await crypto.subtle.digest('SHA-1', audioData))

                const item = sessionStorage.getItem(hash)
                if (item) {
                    const json = JSON.parse(item)
                    console.debug("found item for hash", hash, json)
                    return json
                } 
            }

            async function writeCache(audioData, json) {
                const crypto = window.crypto || window.msCrypto

                const hash = hashToString(await crypto.subtle.digest('SHA-1', audioData))

                return sessionStorage.setItem(hash, JSON.stringify(json))
            }

            async function requestTranscribe(audioData, lang, output="segments") {
                const cachedJson = await checkCache(audioData)
                if (cachedJson) return cachedJson

                const TRANSCRIBE_URL = window.CONFIGURATION.transcribeURL

                const url = TRANSCRIBE_URL + '?src_lang=' + lang + "&output=" + output + "&sampling-rate=44100"
                const response = await fetch(url, {
                    method: 'POST',
                    body: audioData,
                    headers: {
                        'Content-Type': 'audio/raw',
                    },
                })
                const json = await response.json()
                writeCache(audioData, json)
                return json
            }
            
            async function transcribeSegments(lang, audioBuffer, segments, cb) {
                const $health = document.getElementById("transcribe-health")
                $health.innerText = "Transcribing..."
                $health.classList.add("working")

                return new Promise((resolve) => {
                    const completeData = audioBuffer.getChannelData(0)
                    const scale = completeData.length / audioBuffer.duration

                    const transcribeSegment = (i) => {
                        if (i === segments.length) {
                            console.log("Transcription complete.")
                            $health.innerText = "Loaded"
                            $health.classList.remove("working")
                            return resolve()
                        }

                        const segment = segments[i]

                        if (segment.transcribing) return
                        segment.transcribing = true
                        console.debug("Transcribing", segment)

                        const data = completeData.slice(segment.start * scale, segment.end * scale)

                        requestTranscribe(data, lang, "text").then((json) => {
                            transcribeSegment(i+1)

                            segment.text = json.text
                            cb({
                                ...segment,
                                text: json.text
                            })

                            segment.transcribing = false
                        })

                    }

                    transcribeSegment(0)
                })
            }

            // const seedBase = Math.random()
            let seedBase = 398149

            function deterministicValues(input) {
                // Calculate the seed based on the input value
                const seed = (input - 1) * seedBase
                const rng = new Math.seedrandom(seed);

                const value1 = Math.round(rng() * 255);
                const value2 = Math.round(rng() * 255);
                const value3 = Math.round(rng() * 255);

                return [value1, value2, value3];
            }

            function deterministicRgbaValue(input) {
                const colors = deterministicValues(input)
                return `rgba(${colors[0]}, ${colors[1]}, ${colors[2]}, 0.5)`
            }

            function addRegionForSegment(wsRegions, segment) {
                const region = wsRegions.addRegion({
                    id: `segment-${segment.i}`,
                    start: segment.start,
                    end: segment.end,
                    content: segment.text,
                    color: deterministicRgbaValue(segment.i),
                    drag: false,
                    resize: false,
                })
                region.element.style.pointerEvents = 'none'
            }

            function updateRegionForSegment(wsRegions, segment) {
                const region = wsRegions.getRegions().find((region) => region.id === `segment-${segment.i}`)
                region.setContent(segment.text)
            }

            function addRegionsForSegments(wsRegions, segments) {
                console.debug("addRegionsForSegments", segments)
                segments.forEach((segment) => {
                    addRegionForSegment(wsRegions, segment)
                })
            }

            // function getSegmentRegions(wsRegions) {
            //     return wsRegions.getRegions().filter(region => region.id.startsWith("segment-"))
            // }

            function cutSegments(segments, selectionStart, selectionEnd) {
                console.debug("cutSegments", segments, selectionStart, selectionEnd)

                const selectionLength = selectionEnd - selectionStart

                console.log("Cutting out", selectionStart, selectionEnd, selectionLength)

                const overlappingSegments = segments.filter(segment => segment.start < selectionEnd && segment.end > selectionStart)

                overlappingSegments.forEach(segment => {
                    console.log("Overlapping segment", segment)

                    const [oldStart, oldEnd] = [segment.start, segment.end]
                    const oldLength = oldEnd - oldStart

                    if (segment.start >= selectionStart) {
                        if(segment.end <= selectionEnd) {
                            console.debug("Case 1 - complete overlap")
                            console.debug("=> Completely remove segment")

                            const index = segments.indexOf(segment)
                            segments.splice(index, 1)
                        } else {
                            console.debug("Case 2 - selection start before segment and selection end inside segment")

                            const selectionBeforeSegment = segment.start - selectionStart
                            console.debug("=> Decrease start of segment according to selection part before the segment", selectionBeforeSegment)
                            segment.start -= selectionBeforeSegment

                            const selectionInSegment = selectionEnd - segment.start
                            console.debug("=> Decrease end of segment according to selection part inside segment", selectionInSegment)
                            segment.end -= selectionInSegment
                        }
                    } else if (selectionEnd < segment.end) {
                        console.debug("Case 3 - selection start and end inside segment")
                        console.debug("=> Decrease segment end according to selection length")
                        segment.end -= selectionLength
                    } else {
                        console.debug("Case 4 - selection start is inside segment, selection end is after segment end")
                        console.debug("=> Set segment end to selection start")
                        const endPercent = 1 - ((segment.end - selectionStart) / oldLength)
                        segment.end = selectionStart
                    }
                })

                const segmentsAfter = segments.filter(segment => segment.start >= selectionEnd)
                segmentsAfter.forEach(segment => {
                    console.debug("Moving segment", segment.start, segment.end)
                    console.debug("to", segment.start - selectionLength, segment.end - selectionLength)
                    segment.start -= selectionLength
                    segment.end -= selectionLength
                })

                return overlappingSegments
            }

            function pasteIntoSegments(segments, startSeconds, lengthInSeconds) {
                const endSeconds = startSeconds + lengthInSeconds

                const containingSegment = segments.find(segment => segment.start < startSeconds  && segment.end > endSeconds)
                let newSegment
                if (containingSegment) {
                    containingSegment.end += lengthInSeconds
                    console.debug("paste containing segment", containingSegment)

                }

                if (!containingSegment) {
                    const previousSegment = segments.find(segment => segment.start < startSeconds)
                    const previousSegmentIndex = segments.indexOf(previousSegment)
                    const i = previousSegment ? previousSegment.i + 1 : 0

                    newSegment = {
                        i,
                        start: startSeconds,
                        end: endSeconds
                    }
                    segments.splice(previousSegmentIndex + 1, 0, newSegment)
                }

                const segmentsAfter = segments.filter(segment => segment.start > startSeconds)
                segmentsAfter.forEach(segment => {
                    console.debug("Moving segment", segment.start, segment.end)
                    console.debug("to", segment.start + lengthInSeconds, segment.end + lengthInSeconds)
                    if (!containingSegment)
                        segment.i += 1
                    segment.start += lengthInSeconds
                    segment.end += lengthInSeconds
                })

                return containingSegment || newSegment
            }

            function insertSilenceIntoSegments(segments, startSeconds, lengthInSeconds) {
                const endSeconds = startSeconds + lengthInSeconds
                const containingSegment = segments.find(segment => segment.start < startSeconds && segment.end > endSeconds)
                if (containingSegment) {
                    console.debug("insert silence containing segment", containingSegment)
                    containingSegment.end += lengthInSeconds
                }

                const segmentsAfter = segments.filter(segment => segment.start > startSeconds)
                segmentsAfter.forEach(segment => {
                    console.debug("Moving segment", segment.start, segment.end)
                    console.debug("to", segment.start + lengthInSeconds, segment.end + lengthInSeconds)
                    segment.start += lengthInSeconds
                    segment.end += lengthInSeconds
                })
            }

            // function findSegmentRegion(wsRegions, time) {
            //     return getSegmentRegions(wsRegions).reverse().find(region => region.start <= time)
            // }

            function extractSegments(data, duration) {
                const minValue = 0.02
                const minSilenceDuration = 0.5
                const mergeDuration = 0.2
                const scale = duration / data.length

                let start = 0
                let end = 0
                let isSilent = false
                const silentRegions = []

                for (let i=0; i<data.length; i++) {
                    if (data[i] < minValue) {
                        if (!isSilent) {
                            start = i
                            isSilent = true
                        } 
                    } else if (isSilent) {
                        end = i
                        isSilent = false
                        if (scale * (end - start) > minSilenceDuration) {
                            silentRegions.push({
                                start: scale * start,
                                end: scale * end
                            })
                        }
                    }
                }

                // Catch last silent region
                if (isSilent) {
                    silentRegions.push({
                        start: scale * start,
                        end: scale * duration
                    })
                }

                console.debug("silentRegions", silentRegions)

                // Merge silent regions that are close together
                const mergedRegions = []
                let lastRegion = null
                for (let i = 0; i < silentRegions.length; i++) {
                    if (lastRegion && silentRegions[i].start - lastRegion.end < mergeDuration) {
                        lastRegion.end = silentRegions[i].end
                    } else {
                        lastRegion = silentRegions[i]
                        mergedRegions.push(lastRegion)
                    }
                }

                console.debug("mergedRegions", mergedRegions)

                const regions = []
                let lastEnd = 0
                for (let i = 0; i < mergedRegions.length; i++) {
                    if (lastEnd !== mergedRegions[i].start) {
                        regions.push({
                            i,
                            start: lastEnd,
                            end: mergedRegions[i].start,
                        })
                    }
                    lastEnd = mergedRegions[i].end
                }

                return regions
            }

            // function encodeAsFlac(audioBuffer) {
            //     const
            //         CHANNELS = 1,
            //         SAMPLERATE = 16000,
            //         COMPRESSION = 5,
            //         BPS = 16,
            //         VERIFY = true,
            //         BLOCK_SIZE = 0
            //         // flac_ok = 1,
            //         // USE_OGG = false;


            //     const encBuffer = [];

            //     flac_encoder = Flac.create_libflac_encoder(SAMPLERATE, CHANNELS, BPS, COMPRESSION, 0, VERIFY, BLOCK_SIZE);
            //     if (flac_encoder != 0){
            //         const write_callback_fn = function(encodedData /*Uint8Array*/, bytes, samples, current_frame){
            //             //store all encoded data "pieces" into a buffer
            //             encBuffer.push(encodedData);
            //         }

            //         status_encoder = Flac.init_encoder_stream(flac_encoder,
            //             write_callback_fn,    //required callback(s)
            //             // metadata_callback_fn  //optional callback(s)
            //         )
            //         if (status_encoder == 0) {
            //             //convert input data to signed int data, in correspondence to the bps setting (i.e. in this case int32)
            //             // see API docs on FLAC__stream_encoder_process_interleaved() for more details
            //             // const buffer = audioBuffer.getChannelData(0)
            //             const buffer = [1,-1]
            //             var buf_length = buffer.length;
            //             var buffer_i16 = new Int16Array(buf_length);
            //             var view = new DataView(buffer_i16.buffer);
            //             var volume = 1;
            //             var index = 0;
            //             for (var i = 0; i < buf_length; i++){
            //                 view.setInt16(index, (buffer[i] * (32767 * volume)), true);
            //                 index += 2
            //             }
            //             console.log("new buffer", buffer_i16)

            //             flac_return = Flac.FLAC__stream_encoder_process_interleaved(flac_encoder, buffer_i16, buf_length / CHANNELS);
            //             if (flac_return == 0) {
            //                 if (Flac.FLAC__stream_encoder_finish(flac_encoder)) {
            //                     Flac.FLAC__stream_encoder_delete(flac_encoder)
            //                     console.debug("Writing flac done", encBuffer.length)
            //                     console.debug(encBuffer)
            //                 }
            //             } else {
            //                 const state = Flac.FLAC__stream_encoder_get_state()
            //                 console.error("FLAC__stream_encoder_process_interleaved failed", state)
            //             }
            //         } else {
            //             console.error("Flac.init_encoder_stream failed", status_encoder)
            //         }
            //     } else {
            //         Flac.FLAC__stream_encoder_delete(flac_encoder)
            //         console.error("Error initializing the encoder");
            //     }
            // }

            const previousStates = []

            function rememberState(editorState, action) {
                previousStates.unshift({
                    audioBuffer: editorState.audioBuffer,
                    segments: JSON.parse(JSON.stringify(editorState.segments)),
                    action: action
                })

                document.getElementById("undo").innerText = `Undo ${action}`
            }

            function getPreviousState() {
                if (!previousStates.length) return

                const previousState = previousStates.shift()

                return previousState
            }

            async function autoSave(editorState) {
                if (editorState.autoSaveFileHandle) {
                    const $state = document.getElementById("autosave-state")
                    $state.innerText = "Saving..."

                    await saveFile(editorState.autoSaveFileHandle, editorState.wavBlob, false)

                    $state.innerText = editorState.autoSaveFileHandle.name
                }
            }

            function setWorkingMessage(message, showAnimation=true) {
                const $working = document.getElementById("working")

                if (!showAnimation || !message) {
                    $working.innerText = message
                } else {
                    $working.innerHTML = ''

                    for (let i = 0; i < message.length; i++) {
                        let span = document.createElement("span")
                        span.style=`--i:${i}`
                        if (message[i] === ' ') {
                            span.innerHTML = '&nbsp;'
                        } else {
                            span.innerText = message[i]
                        }

                        $working.appendChild(span)
                    }
                }
            }

            function disableActions() {
                document.querySelectorAll(".toolbar .tool").forEach(($tool) => {
                    $tool.disabled = "disabled"
                })
            }

            function reenableActions() {
                document.querySelectorAll(".toolbar .tool").forEach(($tool) => {
                    if ($tool.classList.contains("for-selection")) {
                        if (currentRegion)
                            $tool.disabled = ""
                        else
                            $tool.disabled = "disabled"
                    } else if ($tool.classList.contains("for-copy")) {
                        if (copiedData)
                            $tool.disabled = ""
                        else
                            $tool.disabled = "disabled"
                    } else if ($tool.id === "undo") {
                        if (previousStates.length) {
                            $tool.disabled = ""
                        } else {
                            $tool.disabled = "disabled"
                        }
                    } else {
                        $tool.disabled = ""
                    }
                })
            }

            function startWorking(on) {
                console.debug("Started working on", on)

                disableActions()

                setWorkingMessage(on)
            }

            function stopWorking(message) {
                console.debug("Stopped working")

                reenableActions()

                if (message) {
                    setWorkingMessage(message, false)
                    setTimeout(stopWorking, 1500)
                } else {
                    setTimeout(() => {
                        setWorkingMessage("")
                    }, 250)
                }
            }

            function commandFunction(title, fn) {
                return (args) => {
                    startWorking(title)

                    setTimeout(async () => {
                        await fn(args)
                        stopWorking()
                    })
                }
            }

            async function saveFile(fileHandle, wavBlob, showWorking=true) {
                if (showWorking)
                    startWorking("Saving")

                const writableStream = await fileHandle.createWritable();

                await writableStream.write(wavBlob);
                await writableStream.close();

                if (showWorking)
                    stopWorking("Saved.")
            }

            async function transcribeAllSegments(lang, editorState, wsRegions) {
                console.debug("Transcribing all segments", editorState.segments)

                editorState.segments.forEach((segment) => addRegionForSegment(wsRegions, segment))
                await transcribeSegments(lang, editorState.audioBuffer, editorState.segments, (segment) => {
                    updateRegionForSegment(wsRegions, segment)
                })

            }

            async function init() {
                let simplePeer
                let simplePeerConnected = false
                let transcriptionLang
                const editorState = {
                    audioBuffer: undefined,
                    wavBlob: undefined,
                    segments: undefined,
                    autoSaveFileHandle: undefined
                }

                const audioCtx = new (window.AudioContext || window.webkitAudioContext)()
                editorState.audioBuffer = audioCtx.createBuffer(1, 1, SAMPLE_RATE)

                const waveSurfer = new WaveSurfer({
                    container: '#waveform',
                    waveColor: '#4F4A85',
                    progressColor: '#383351',
                    cursorColor: '#ddd5e9',

                    plugins: [
                        WaveSurfer.Timeline.create({
                            primaryLabelInterval: 1,
                            // timeInterval: 0.1,
                            // formatTimeCallback: (seconds) => seconds        // TODO Remove (only debugging)
                        }),
                        WaveSurfer.Minimap.create({
                            height: 20,
                            waveColor: '#ddd',
                            progressColor: '#999',
                            // the Minimap takes all the same options as the WaveSurfer itself
                        }),
                      WaveSurfer.Zoom.create({
                          // the amount of zoom per wheel step, e.g. 0.5 means a 50% magnification per scroll
                          scale: 0.25,
                          // Optionally, specify the maximum pixels-per-second factor while zooming
                          maxZoom: MAX_ZOOM,
                      }),
                      WaveSurfer.Hover.create({
                        lineColor: 'yellow',
                        labelColor: 'yellow',
                        labelSize: '20px'
                      }),
                    ],
                    height: 512,
                    minPxPerSec: 100,
                })

                const wsRegions = waveSurfer.registerPlugin(WaveSurfer.Regions.create())

                const $minPxPerSec = document.querySelector('#min-px-per-sec')
                waveSurfer.on('zoom', (minPxPerSec) => {
                    if (minPxPerSec < MIN_ZOOM) {
                        minPxPerSec = MIN_ZOOM
                        console.debug("Resetting zoom to", minPxPerSec)
                        waveSurfer.zoom(minPxPerSec)
                    }

                    $minPxPerSec.textContent = `Zoom: ${Math.round(minPxPerSec)}`
                })

                editorState.segments = extractSegments(editorState.audioBuffer.getChannelData(0), editorState.audioBuffer.duration)
                console.debug("found segments", editorState.segments)

                editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                waveSurfer.on('decode', async () => {
                    console.log("decoded")

                    wsRegions.clearRegions()

                    editorState.segments.forEach((segment) => addRegionForSegment(wsRegions, segment))
                })

                const formatTime = (seconds) => {
                    const minutes = Math.floor(seconds / 60)
                    const secondsRemainder = (seconds % 60).toFixed(2)
                    const paddedSeconds = secondsRemainder > 10 ? secondsRemainder : `0${secondsRemainder}`
                    return `${minutes}:${paddedSeconds}`
                }
                const $time = document.getElementById('time')
                const $duration = document.getElementById('duration')
                waveSurfer.on('timeupdate', (currentTime) => ($time.textContent = formatTime(currentTime)))
                waveSurfer.on('decode', (duration) => ($duration.textContent = formatTime(duration)))
                WaveSurfer.Hover.prototype.formatTime = formatTime

                waveSurfer.on('scroll', async (visibleStartTime, visibleEndTime) => {
                    if (!transcriptionLang) return

                    const duration = visibleEndTime - visibleStartTime
                    const startTime = visibleStartTime - duration
                    const endTime = visibleEndTime + duration

                    const segmentsToTranscribe = editorState.segments.filter((segment) => {
                        return !segment.text && !segment.transcribing && (
                            (segment.start >= startTime && segment.start <= endTime) ||
                            (segment.end >= startTime && segment.end <= endTime)
                        )
                    })

                    if (segmentsToTranscribe.length) {
                        console.debug("Transcribe b/c of scroll", segmentsToTranscribe)
                        await transcribeSegments(transcriptionLang, editorState.audioBuffer, segmentsToTranscribe, (segment) => {
                            updateRegionForSegment(wsRegions, segment)
                        })
                    }
                })

                wsRegions.enableDragSelection({
                        color: 'rgba(221, 213, 233, 0.5)',
                })

                wsRegions.on('region-created', (region) => {
                    if (region.id.startsWith("segment-")) return

                    if (currentRegion) {
                        try {
                            currentRegion.remove()
                        } catch {
                            console.error("FIXME Tried to remove non-existing region")
                        }
                    }

                    if (region.start < 0.02) region.setOptions({start: 0})
                    console.log('Created region', region)

                    currentRegion = region

                    region.on('over', () => {
                        console.log("Over region", region)
                    })

                    reenableActions()
                })

                wsRegions.on("region-clicked", (region, e) => {
                    if (region.id.startsWith("segment-")) return
                    e.stopPropagation() // prevent triggering a click on the waveform

                    console.log("region-clicked", region, e)
                    region.play()
                })

                wsRegions.on("region-double-clicked", (region, e) => {
                    // FIXME This somehow does not trigger on segments
                    console.log("region-double-clicked", region, e)

                    if (region.id.startsWith("segment-")) {
                        region.play()
                    } else {
                        region.remove()
                        currentRegion = undefined

                        reenableActions()
                    }

                })

                wsRegions.on('region-in', (region) => {
                  console.debug("Entered region", region.content)
                  if (simplePeerConnected && region.content?.innerText) {
                    simplePeer.send(region.content.innerText)
                  }
                })

                wsRegions.on('region-out', (region) => {
                    if (region.id.startsWith("segment-")) return
                    console.log("region-out", region)

                    waveSurfer.pause()
                })
                
                waveSurfer.on('dblclick', async () => {
                    await waveSurfer.playPause()
                })

                waveSurfer.on('click', () => {
                    if (waveSurfer.isPlaying())
                        waveSurfer.pause()
                })

                document.getElementById("pause").addEventListener("click", () => {
                    waveSurfer.playPause()
                })

                document.addEventListener("keydown", async (event) => {
                    switch(event.keyCode) {
                        case 17:    // CTRL
                            document.querySelectorAll(".toolbar").forEach(($el) => $el.classList.add("show-shortcuts"))
                            break
                    }
                })

                document.addEventListener("keyup", async (event) => {
                    console.debug("keyCode", event.keyCode)

                    if (event.ctrlKey) {
                        switch(event.keyCode) {
                            case 67:    // c
                                event.preventDefault()
                                setTimeout(copyCommand.bind(this))
                                break
                            case 73:    // i
                                event.preventDefault()

                                const length = parseFloat(prompt("Silence duration in seconds:", "1.0"))
                                if (length)
                                    setTimeout(insertSilenceCommand.bind(this, length))
                                break
                            case 77:    // m
                                event.preventDefault()
                                setTimeout(strangleCommand.bind(this))
                                break
                            case 86:    // p
                                event.preventDefault()
                                setTimeout(pasteCommand.bind(this))
                                break
                            case 88:    // x
                                event.preventDefault()
                                setTimeout(cutCommand.bind(this))
                                break
                            case 90:    // x
                                event.preventDefault()
                                setTimeout(undoCommand.bind(this))
                                break
                        }
                    }
                    else {
                        switch(event.keyCode) {
                            case 32:    // SPACE
                                event.preventDefault()
                                await waveSurfer.playPause()
                                break
                            case 46:  // DEL
                                event.preventDefault()
                                setTimeout(cutCommand.bind(this))
                                break
                            case 17:    // CTRL
                                document.querySelectorAll(".toolbar").forEach(($el) => $el.classList.remove("show-shortcuts"))
                                break
                        }
                    }
                })

                const copyCommand = commandFunction("Copying", async () => {
                    const [start, end] = [currentRegion.start, currentRegion.end]

                    copiedData = await copy(editorState.audioBuffer, start, end)

                    console.debug("copied audio from / until", start, end)
                    
                    document.getElementById("paste").disabled = ""
                })

                document.getElementById("copy").addEventListener("click", copyCommand.bind(this))

                const pasteCommand = commandFunction("Pasting", async () => {
                    wsRegions.clearRegions()

                    rememberState(editorState, "paste")

                    const start = waveSurfer.getCurrentTime()
                    const length = copiedData.length / editorState.audioBuffer.sampleRate

                    console.debug("Pasting audio start / length", start, length)

                    const affectedSegment = pasteIntoSegments(editorState.segments, start, length)

                    editorState.audioBuffer = await paste(editorState.audioBuffer, copiedData, start)

                    console.log("Loading new audio buffer", editorState.audioBuffer)

                    editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                    autoSave(editorState)

                    waveSurfer.setTime(start)

                    if (affectedSegment) {
                        if (transcriptionLang) {
                            await transcribeSegments(transcriptionLang, editorState.audioBuffer, [affectedSegment], (updatedSegment) => {
                                const segment = editorState.segments.find((s) => s.i === updatedSegment.i)
                                if (segment) {
                                    console.debug("Updating segment text for", segment, updatedSegment.text)
                                    segment.text = updatedSegment.text
                                    updateRegionForSegment(wsRegions, segment)
                                }
                            })
                        }
                    }

                    // addRegionsForSegments(wsRegions, segments)
                })

                document.getElementById("paste").addEventListener("click", pasteCommand.bind(this))

                const cutCommand = commandFunction("Cutting", async () => {
                    if(!currentRegion) return

                    document.getElementById("cut").disabled = "disabled"

                    const [start, end] = [currentRegion.start, currentRegion.end]

                    currentRegion.remove()
                    currentRegion = undefined

                    wsRegions.clearRegions()

                    rememberState(editorState, "cut")

                    const overlappingSegments = cutSegments(editorState.segments, start, end)

                    const result = await cut(editorState.audioBuffer, start, end)
                    editorState.audioBuffer = result[0]
                    copiedData = result[1]

                    console.log("Loading new audio buffer", editorState.audioBuffer)

                    editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                    autoSave(editorState)

                    waveSurfer.setTime(start)
                    
                    if(transcriptionLang) {
                        await transcribeSegments(transcriptionLang, editorState.audioBuffer,  overlappingSegments, (updatedSegment) => {
                            const segment = editorState.segments.find((s) => s.i === updatedSegment.i)
                            if (segment) {
                                console.debug("Updating segment text for", segment, updatedSegment.text)
                                segment.text = updatedSegment.text
                                updateRegionForSegment(wsRegions, segment)
                            }
                        })
                    }

                    addRegionsForSegments(wsRegions, editorState.segments)

                    document.getElementById("paste").disabled = ""
                    document.getElementById("undo").disabled = ""
                })

                document.getElementById("cut").addEventListener("click", cutCommand.bind(this))

                const undoCommand = commandFunction("Undoing", async () => {
                    const currentTime = waveSurfer.getCurrentTime()

                    if (previousStates.length == 0) return

                    ({audioBuffer: editorState.audioBuffer, segments: editorState.segments} = getPreviousState())
                    editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                    autoSave(editorState)

                    addRegionsForSegments(wsRegions, editorState.segments)

                    waveSurfer.setTime(currentTime)

                    const $undo = document.getElementById("undo")

                    if (previousStates.length > 0) {
                        $undo.innerText = `Undo ${previousStates[0].action}`
                    }
                    else {
                        $undo.innerText = "Undo"
                        setTimeout(() => $undo.disabled = "disabled")        // Somehow setTimeout is necessary here
                    }
                })

                document.getElementById("undo").addEventListener("click", undoCommand.bind(this))

                const strangleCommand = commandFunction("Strangling", async () => {
                    const [start, end] = [currentRegion.start, currentRegion.end]

                    rememberState(editorState, "strangle")

                    editorState.audioBuffer = await strangle(editorState.audioBuffer, start, end)

                    console.debug("strangled audio from / until", start, end)

                    editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                    autoSave(editorState)

                    waveSurfer.setTime(start)

                    addRegionsForSegments(wsRegions, editorState.segments)
                })

                document.getElementById("strangle").addEventListener("click", strangleCommand.bind(this))

                const insertSilenceCommand = commandFunction("Inserting silence", async (length) => {
                    wsRegions.clearRegions()

                    const start = waveSurfer.getCurrentTime()

                    rememberState(editorState, "insert silence")

                    console.debug("Insert silence start / length", start, length)

                    insertSilenceIntoSegments(editorState.segments, start, length)

                    editorState.audioBuffer = await insertSilence(editorState.audioBuffer, start, length)

                    console.log("Loading new audio buffer", editorState.audioBuffer)

                    editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                    autoSave(editorState)

                    waveSurfer.setTime(start)

                    addRegionsForSegments(wsRegions, editorState.segments)
                })

                document.getElementById("insert-silence").addEventListener("click", () => {
                    const length = parseFloat(prompt("Silence duration in seconds:", "1.0"))

                    if (length)
                        insertSilenceCommand(length)
                })

                document.getElementById("open-file").addEventListener("change", (event) => {
                    const file = event.target.files[0]
                    seedBase = stringHash(file.name)
                    console.debug("Setting seedBase", seedBase)

                    startWorking("Loading file")

                    const reader = new FileReader()
                    reader.addEventListener("loadend", async () => {
                        const ctx = new AudioContext({
                            sampleRate: SAMPLE_RATE,
                            numChannels: 1
                        })

                        editorState.audioBuffer = await ctx.decodeAudioData(reader.result)

                        editorState.segments = extractSegments(editorState.audioBuffer.getChannelData(0), editorState.audioBuffer.duration)
                        console.debug("found segments", editorState.segments)

                        editorState.wavBlob = await loadDecodedBuffer(waveSurfer, editorState.audioBuffer)

                        stopWorking("File loaded.")
                    })
                    reader.readAsArrayBuffer(file)
                })

                document.getElementById("save-wav").addEventListener("click", async () => {
                    if (typeof window.showSaveFilePicker !== "undefined") {
                        // Use Filesystem API as it is available

                        const fileHandle = await window.showSaveFilePicker({
                            id: "save-file",
                            excludeAcceptAllOption: true,
                            types: [
                                {
                                    description: "WAV file",
                                    accept: {"audio/wav": [".txt"]}
                                }
                            ]
                        });

                        if (fileHandle) {
                            await saveFile(fileHandle, editorState.wavBlob)
                        }
                    } else {
                        const url = URL.createObjectURL(editorState.wavBlob);

                        const link = document.createElement('a');
                        link.href = url;
                        link.download = 'processed.wav'
                        link.style.display = 'none';

                        document.body.appendChild(link);

                        link.dispatchEvent(new MouseEvent('click'));

                        document.body.removeChild(link);
                    }
                })

                document.getElementById("toggle-autosave").addEventListener("click", async () => {
                    if (editorState.autoSaveFileHandle) {
                        editorState.autoSaveFileHandle = undefined
                        document.getElementById("autosave-state").innerText = ""
                        document.getElementById("toggle-autosave").innerText = "Enable Autosave"
                    } else {
                        editorState.autoSaveFileHandle = await window.showSaveFilePicker({
                            id: "autosave-file",
                            suggestedName: "autosave.wav",
                            excludeAcceptAllOption: true,
                            types: [
                                {
                                    description: "WAV file",
                                    accept: {"audio/wav": [".txt"]}
                                }
                            ]
                        });

                        document.getElementById("autosave-state").innerText = editorState.autoSaveFileHandle.name
                        document.getElementById("toggle-autosave").innerText = "Disable Autosave"
                    }
                })

                document.getElementById("transcription-lang").addEventListener("change", async () => {
                    transcriptionLang = document.getElementById("transcription-lang").value
                    if (transcriptionLang && editorState.segments.length) {
                        console.debug("Activating transcription service")

                        document.getElementById("transcribe-health").innerHTML = "Loading..."

                        const url = new URL(window.CONFIGURATION.transcribeURL)
                        url.pathname = "/.well-known/health"
                        const response = await fetch(url, {method: 'GET'})

                        if (response.ok) {
                            document.getElementById("transcribe-health").innerHTML = "Loaded"
                        }
                    }
                })

                document.getElementById("connect-to-text-page").addEventListener("click", async () => {
                    document.getElementById("connect-to-text-page").disabled = true

                    simplePeer = new SimplePeer({
                        initiator: false,
                        trickle: false
                    })

                    simplePeer.on('error', err => console.log('error', err))

                    simplePeer.on('signal', async (data) => {
                        console.log('SIGNAL', JSON.stringify(data))
                        await navigator.clipboard.writeText(JSON.stringify(data))

                        const text = `
                        The answer code has been copied to your clipboard. These are the next steps: 

                        1. Go back to the page with the text. 
                            a. Paste the code from the clipboard into the text field in the popup.
                            b. Hit "Submit".
                        2. Click "Ok" here.

                        The browser windows are now connected and you are ready to go!
                        `.replace(/  +/g, '')
                        alert(text)
                    })

                    simplePeer.on('connect', () => {
                        console.log('Peer connected')
                        simplePeerConnected = true
                        document.getElementById("connected-to-text-page").innerHTML = "Connected"
                    })

                    simplePeer.on('data', data => {
                        console.log('Data from peer: ' + data)
                    })

                    simplePeer.on('close', () => {
                        console.log('Peer closed the connection')
                        simplePeer.destroy()
                        simplePeerConnected = false
                        document.getElementById("connected-to-text-page").innerHTML = "Disconnected"
                        document.getElementById("connect-to-text-page").disabled = false
                    })

                    const code = `const script = document.createElement("script"); script.src = "${window.CONFIGURATION.textHighlighterURL}"; document.querySelector("body").appendChild(script)`
                    await navigator.clipboard.writeText(code)

                    let text = `
                    You are about to connect the editor to the page which contains the original text. The data for the connection has just been copied to your clipboard. These are the next steps: 

                    1. In another browser window, load the page which contains the original text. 
                        a. After the text is loaded, open the web developer console (F12)
                        b. In the console, paste the text from your clipboard. Hit ENTER.
                        b. Close the developer console.
                        c. An overlay window will have opened. Click on "Copy offer to clipboard".
                    2. Come back here, paste the whole string from your clipboard into the following text field. Afterwards, hit Ok.
                    3. After a few seconds, a new window will appear here.
                    `.replace(/  +/g, '')

                    const offer = prompt(text)
                    if (offer) {
                        document.getElementById("connected-to-text-page").innerHTML = "Connecting..."
                        simplePeer.signal(JSON.parse(offer))
                    }
                })
            }

            init()
        </script>
    </body>
</html>
